# external imports
from pygame import Surface, Vector2
from typing import Optional

# internal imports
from bin.map import Block
from bin.map import Chunk
from bin.abstractClasses import Executor, Reason
from bin.event import Event


# ----------------------
# ADDITIONAL INFOMATION
# ----------------------
# 1. You can access any texture that you've specified in class variables by typing just self.[TEXTURE_NAME]_RENDER, 
# because during intialization of the namespace, resourceManager leaves this variable.
# you shall not use pygame.image.load() or similar things because that slower 
# (namespace is intialized once and you use the same texture for multiple objects)
# 2. all files starting with _ will be ignored and won't be loaded by resourceManager (they won't be loaded into game)
# 3. you shouldn't include methods in your class that you want to change! 
# it will just unnecessarily make loading time and size of the file longer/bigger
# 4. File name, class name and string id should be as following: [stringID].py, [stringID], [stringID]
# 5. you can include as many things in this file as you want (even imports or another classes),
# you only can't include any others blocks or entities.
# If you want them use existing methods or resourceManager
# 6. idInt works only for blocks and string id is prioritized
# 7. idInts and stringIds can't be ambigious, you can't use them over again. Every id have to specify one block.
# 8. paths for images, etc. starts with "resources/" you don't need to add that.
# 9. hi?


class BLOCKID(Block):
    '''just block :3'''
    # basic information about block (info that can be changed in every block)
    MAINTEXTURE: str | None = None  # texture that will be used
    MAINTEXTUREISTRANSPARENT: bool = False # if texture is transparent (that is only for pygame optimization)
    ID: str | None = None   # string ID (UNIQUE, MAIN ID)
    IDInt: int|None = None  # int ID (UNIQUE)
    
    # advanced information about block (info that can be changed in every block)
    listenToMe: bool = False # should game look out for this block to update it necessary (useful for crops or another things like that, that doesn't affect any updates that are caused by other blocks or entities. that's auto updates) {NOT IMPLEMENTED YET}
    listenPriority: int = 1 # priority of listening. The higher the better. {NOT IMPLEMENTED YET}
    
    
    # lighting information
    
    lightingAbsorption = 4 # tells lighting engine how that should be treated (if that should absorb the light)
    
    # SCREENSIZE = (1280,720) # SIZE OF SCREEN (IDK IF THAT WAS USED ANYWHERE BUT ILL KEEP IT FOR SECURITY REASONS)
    
    # functions to changed in every block:
    
     

    
    # function run once block is generated by world generator (requirement to be invoked: Reason.worldGenerator)
    def onGenerate(self, cordsRelative: Vector2, cordsAbsolute: Vector2, inChunkPosition: tuple[int,int], chunk: Chunk, executor: Optional[Executor] = None) -> None:
        '''Method executed when chunk is generated, can be changed in every block'''
        raise NotImplementedError('Attempted to call a not implemented method!')
    
    # function run once block is loaded from save (requirement to be invoked: Reason.chunkRestore)
    def onLoad(self, cordsRelative: Vector2, cordsAbsolute: Vector2, inChunkPosition: tuple[int,int], chunk: Chunk, executor: Optional[Executor] = None) -> None:  
        '''Method executed when chunk is loaded, can be changed in every block'''
        raise NotImplementedError('Attempted to call a not implemented method!')
    
    @staticmethod
    def onPlaceAttempt(blockPosAbsolute: tuple[int,int], inChunkPosition: tuple[int,int], chunk: Chunk, event: Event, reason: Optional[Reason] = None, executor: Optional[Executor] = None, changingBlock: bool = False) -> None:  
        '''method executed when block would be break (if you really want BLOCK OBJECT YOU MUST INTIALIZE EVENT BY event.do() (that function will return object of that block))'''
        raise NotImplementedError('Attempted to call a not implemented method!')
    
    def onBreakAttempt(self, blockPosAbsolute: tuple[int,int], inChunkPosition: tuple[int,int], chunk: Chunk, event: Event, reason: Optional[Reason] = None, executor: Optional[Executor] = None) -> None:  
        '''method executed when block would be break'''
        raise NotImplementedError('Attempted to call a not implemented method!')
    
    def onUpdate(self, blockPosAbsolute: tuple[int,int], inChunkPosition: tuple[int,int], chunk: Chunk, event: Event, reason: Optional[Reason] = None, executor: Optional[Executor] = None) -> None:  
        '''method that is run every time block received that it should update itself.\n
            current reasons to cause update:
            * method .causeUpdate() or .causeUpdateOnNeighbours
            * destroying/placing/changing neighbour of this block (only after event is done! on attempts event is still not done, you must force event to be done by using event.do())'''
        raise NotImplementedError('Attempted to call a not implemented method!')
    
    
    # # TODO: function that run every update
    # # TODO: function that run every update (for listeners)
    
    # def update(self, *args, **kwargs):
    #     raise NotImplementedError('Not implemented')

    def lupdate(self, *args, **kwargs):
        raise NotImplementedError('Attempted to call a not implemented method!')
        
    # you shouldn't touch too much i in init, only if you're sure what you're doing
    def __init__(self, image: Surface, blockPos: Vector2, chunk: Chunk, background: bool = False, executor: Executor | None = None, reason: str | None = None, addToEverything: bool = True) -> None:
        super().__init__(image, blockPos, chunk, executor, reason, addToEverything)
    